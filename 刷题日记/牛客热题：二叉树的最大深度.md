# 牛客热题：二叉树的最大深度

## 题目链接

[二叉树的最大深度_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tqId=642&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

## 方法一：递归

### 思路

1. 首先进行递归终止条件的判断：如果当前节点为空，则返回深度 0。
2. 接着判断当前节点是否为叶子节点（即左右子节点均为空）：
   - 如果是叶子节点，则返回深度 1，表示当前节点为一层。
3. 如果不是叶子节点，则分别递归地计算左子树和右子树的最大深度，得到左子树的深度 `l` 和右子树的深度 `r`。
4. 最终返回大深度的值加 1，即 `max(l, r) + 1`，表示当前节点所在层的深度。

这样通过递归的方式，从根节点开始逐层向下计算深度，直到叶子节点为止，最终得到整棵树的最大深度。

### 代码

```cpp
    int maxDepth(TreeNode* root) 
    {
        if(root == nullptr) return 0;
        //叶子节点
        if(root->left == nullptr && root->right == nullptr) return 1;

        int l = maxDepth(root->left);
        int r = maxDepth(root->right);
        return (l > r ? l : r) + 1;
    }
```

### 复杂度

> 这个函数的时间复杂度和空间复杂度如下：
>
> - **时间复杂度：O(N)**
>   
>   - 其中，N 是二叉树中的节点数。
>   - 函数需要遍历每个节点一次，对于每个节点，都需要进行常数时间的判断和递归调用。
>   
> - **空间复杂度：O(N)**
>
>   对于空间复杂度，在最坏情况下，递归调用会将所有节点压入调用栈，导致空间复杂度为 O(N)。
>

## 方法二：层序遍历

### 思路

> 这段代码使用了广度优先搜索（BFS）的思路来计算二叉树的最大深度。让我来解释一下它的思路：
>
> 1. 首先，检查根节点是否为空。如果为空，则返回深度为 0。
> 2. 如果根节点不为空，则创建一个队列 `q`，并将根节点压入队列。
> 3. 接着，定义一个变量 `res` 用来保存深度，初始化为 0。
> 4. 进入循环，只要队列不为空，就执行以下操作：
>    - 获取当前队列的大小，表示当前层的节点数，记为 `n`。
>    - 遍历当前层的所有节点，对于每个节点：
>      - 弹出队列中的节点 `cur`。
>      - 如果 `cur` 的左子节点不为空，则将其加入队列。
>      - 如果 `cur` 的右子节点不为空，则将其加入队列。
>    - 完成一层的遍历后，计为每个节点都会入队出队各一次，所以时间复杂度为 O(N)，其中 N 是二叉树的节点数。由于使用了队列，空间复杂度为 O(W)，其中 W 是二叉树中最大的层的节点数，通常是二叉树的宽度。

### 代码

```cpp
 int maxDepth(TreeNode* root) 
    {
        if(root == nullptr) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 0;
        while(!q.empty())
        {
            int n = q.size();
            for(int i = 0; i < n; ++i)
            {
                TreeNode* cur = q.front();
                q.pop();
                if(cur->left != nullptr) q.push(cur->left);
                if(cur->right != nullptr) q.push(cur->right);
            }
            res++;
        }

        return res;
    }
```

### 复杂度

> - 时间复杂度：O(N)
>   - 其中，N 是二叉树中的节点数。
>   - 在最坏情况下，需要遍历每个节点一次，对于每个节点，都需要进行常数时间的操作。
>
> - 空间复杂度：O(W)
>   - 其中，W 是二叉树的最大宽度，即二叉树中最宽的那一层的节点数。
>   - 在队列中同时存储一层的所有节点，因此空间复杂度取决于二叉树的宽度。
>
> 综上所述，这段代码的时间复杂度为 O(N)，空间复杂度为 O(W)。