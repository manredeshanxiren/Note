# 跳跃游戏系列

## 1.跳跃游戏Ⅰ

### 思路

### 代码

### 复杂度

## 2.跳跃游戏Ⅱ

### 方法一：动态规划

#### 思路

1. 首先，确定问题是计算到达数组末尾所需的最少跳跃次数。这里使用了动态规划的方法来解决问题。
2. 创建一个大小为 `n`（`nums` 数组的大小）的 `dp` 数组，其中 `dp[i]` 表示到达位置 `i` 所需的最少跳跃次数。初始时，将所有位置的最小跳跃次数设为 `INT_MAX`，表示初始状态下还不知道到达这些位置的最小跳跃次数。
3. 由于一开始就在位置 `0`，所以将 `dp[0]` 设为 `0`，表示到达位置 `0` 不需要跳跃。
4. 然后通过两层循环来更新dp数组的值。
   - 外层循环遍历数组的每个位置 `i`。
   - 内层循环考虑从位置 `i` 能够跳跃到的位置。如果从位置 `i` 跳跃 `j` 步能够到达位置 `i + j`，并且 `i + j` 没有超出数组范围，那么就更新 `dp[i + j]` 的值。更新的方法是将 `dp[i + j]` 更新为 `min(dp[i + j], dp[i] + 1)`，即如果从位置 `i` 经过一次跳跃到达位置 `i + j` 的跳跃次数比之前已知的到达位置 `i + j` 的跳跃次数更少，就更新 `dp[i + j]` 的值。
5. 最后，返回 `dp[n - 1]`，即到达数组末尾位置所需的最少跳跃次数。

#### 代码

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, INT_MAX);
        
        dp[0] = 0;

        for(int i = 0; i < n; ++i) {
            for(int j = 1; j <= nums[i] && i + j < n; ++j) {
                dp[i + j] = min(dp[i + j], dp[i] + 1);
            }
        }

        return dp[n - 1];
    }
};
```

#### 复杂度	

> **时间复杂度**：O($2 ^ n$)外层循环遍历 `n` 个位置，内层循环在最坏情况下，对于每个位置 `i`，可能需要遍历 `nums[i]` 个位置，所以总的时间复杂度为 ，其中 `n` 是数组 `nums` 的长度。
>
> **空间复杂度**：O(N)创建了一个大小为 `n` 的 `dp` 数组来存储中间结果，所以空间复杂度为O(N) 

### 方法二：贪心

#### 思路

1. **变量初始化**：
   - 首先初始化三个变量：
     - `jumps`表示当前的跳跃次数，初始值为 0。
     - `currentEnd`表示当前跳跃能够到达的最远位置，初始值为 0。
     - `farthest`表示从当前位置出发能够到达的最远位置，初始值为 0。
2. **遍历数组**：
   - 从数组的第一个位置开始遍历，直到遍历到数组的最后一个位置的前一个位置。
   - 对于每个位置`i`，更新`farthest`为当前位置`i`加上能够跳跃的最大步数`nums[i]`和原来的`farthest`中的较大值。这一步的目的是确定从当前位置出发能够到达的最远位置。
3. **判断是否需要跳跃**：
   - 当遍历到当前能够到达的最远位置`currentEnd`时，说明需要进行一次跳跃。此时，更新`jumps`和`currentEnd`为新的能够到达的最远位置，即`currentEnd = farthest`，同时跳跃次数`jumps`加一。
4. **返回结果**：
   - 遍历结束后，`jumps`就是到达数组末尾所需的最少跳跃次数。

#### 代码

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int jumps = 0;
        int currentEnd = 0;
        int farthest = 0;

        for (int i = 0; i < n - 1; ++i) {
            farthest = max(farthest, i + nums[i]);
            if (i == currentEnd) {
                jumps++;
                currentEnd = farthest;
            }
        }

        return jumps;
    }
};
```

#### 复杂度

> 时间复杂度：O(N)
>
> 空间复杂度：O(1)