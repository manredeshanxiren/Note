# C++快速幂

# 题目描述

> [LCR 134. Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

# 解题思路

> 借用递归的思路实现pow函数：
>
> 首先我们来举两个例子：
>
> **偶数：**
>
> $ 2^{16}$--->$2 ^ 8$ * $2 ^ 8$     |      $2 ^ 8$ --->$2 ^ 4$ * $2 ^ 4$     |     $2 ^ 4$ --->$2 ^ 2$ * $2 ^ 2$      |       $2 ^ 2$ ---> 2 * 2 
>
> **奇数：**
>
> $2 ^{21}$--->$2 ^ {10}$ * $2^{10}$ * $2$     |      $2 ^{10}$ ---> $2 ^ {5}$  * $2 ^ 5$       |      $2 ^ 5$ ---> $2 ^ 2$ * $2^2$  * 2      |    $2 ^ 2$ ---> $2$ * $2$;
>
>  从上面的例子我们也可以看出一个共同的子问题：
>
> 如果我们要计算$x ^ n$ 那么我们先计算 $x ^ {n / 2}$, 通过这样的方法我们就可以将计算n次方的时间复杂度降到$log _2 ^ n$
>
> 那么答题思路就是如上所示。
>
> **细节：**
>
> 当n = $-2 ^ {31}$的时候我们将它转成正数会越界，所以我们在转化之前将它转成`longlong`即可解决；

# 代码

```cpp
class Solution {
public:
    double myPow(double x, int n) 
    {
        return n < 0 ? 1.0 / pow(x, -(long long)n) : pow(x, n);
    }

    double pow(double x, long long n)
    {
        if(n == 0) return 1;
        double tmp = pow(x, n / 2);
        return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
    }
};
```

# 复杂度分析

> **时间复杂度：**
>
> 采用了快速幂的算法思路我们只需要O($log^n$)的复杂度即可解决问题；
>
> **空间复杂度：**
>
> 每次递归中都声明了一个临时变量`tmp`,所以空间复杂度是O($log ^ n$);