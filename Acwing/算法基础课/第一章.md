# 第一章

## Ⅰ.排序

### Ⅰ. Ⅰ 快排

> 思路：
>
> ​	平均时间复杂度：`nlogn`;
>
> ​	①确定分界点：即选择一个标准值`key`，`key`的选取方法有`q[l]`， `q[(l + r) / 2]`,  `q[r]`，随机；
>
> ​	②调整位置：将数组分为两个区间，前半部分区间都是`q[i] <= key`, 后半部分区间都是 `q[i] >= key` 
>
> ​	③递归处理左右两端的区间；
>
> 模板：
>
> ```cpp
> #include<iostream>
> 
> using namespace std;
> const int N = 1e6 + 10;
> 
> int n;
> int q[N];
> 
> void quick_sort(int q[], int l, int r)
> {
>     if(l >= r) return;
>     
>     int x = q[l], i = l - 1, j = r + 1;
>     while(i < j)
>     {
>         do i++; while(q[i] < x);
>         do j--; while(q[i] > x);
>         if(i < j) swap(q[i], q[j]);
>     }
>    	quick_sort(q,l,j);
>     	quick_sort(q,j + 1, r);
> }
> 
> int main()
> {
>     scanf("%d", &n);
>     for(int i = 0; i < n; ++i) scanf("%d", &q[i]);
> 	
>     quick_sort(q,l,r);
>     
>     for(int i = 0; i < nl ++i) printf("%d ",q[i]);
>     
>     return 0;
> }
> ```
>
> 注意：
>
> ​	对于边界问题：
>
> ​	当我们选择key为q[l]的时候，那么递归的时候边界就只能是：
>
> ```CPP
>    	quick_sort(q,l,j);
>     quick_sort(q,j + 1, r);
> ```
>
> 如果边界是如下所示的情况，就容易造成死递归，举例数组为`1  2`的情况：
>
> 这时候`key`就是1，那么如下条件就会变成左区间`[0, -1]`, 右区间`[0, 1]`就会死递归了。
>
> 所以为了避免这种情况，当选取`key`为`q[l]`的时候选用上面的区间即可，当选取`key`为`q[r]`的时候我们选用下面的区间即可。
>
> ```CPP
>    	quick_sort(q,l,i - 1);
>     quick_sort(q,i, r);
> ```
>
> 

### Ⅰ. Ⅱ 归并

> 思路：
>
> ​	时间复杂度：`nlogn`;
>
> ​	①确定分界点`mid = (l + r) / 2`;
>
> ​	②不断的将数组进行分解，直到分解为一个一个为一组为止。
>
> ​	③将这些分解完的**<u>有序</u>**数组一个一个进行<u>**有序**</u>合并。
>
> 模板：
>
> ```cpp
> #include<iostream>
> 
> using namespace std;
> 
> const int N = 1000010;
> 
> int n;
> int q[N], tmp[N];
> 
> void merge_sort(int q[], int l, int r)
> {
>  if (l >= r) return;
>     
>  int mid = (l + r) >> 1;
>     
>  merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
>     
>  int k = 0, i = l, j = mid + 1;
>  while (i <= mid && j <= r)
>      if (q[i] <= q[j]) tmp[k++] = q[i++];
>      else tmp[k++] = q[j++];
>  while (j <= r) tmp[k++] = q[j++];
>  while (i <= mid) tmp[k++] = q[i++];
>     
>  for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
> }  
> int main()
> {
> 	int n;
>  scanf("%d", &n);
>  for(int i = 0; i < n; i++) scanf("%d", &q[i]);
> 
>  merge_sort(q, 0, n);
> 
>  for(int i = 0; i < n; i++) printf("%d ", q[i]);
> 	return 0;
> }
> ```
>

## Ⅱ. 二分

> 思路：
>
> ​	二分的本质并不是单调性，二分的本质是**存在一个边界使得点右边的区间满足条件，左边的区间不满足条件。**
>
> ​	<img src="C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230425111435365.png" alt="image-20230425111435365" style="zoom: 25%;" />
>
> ### 整数二分：	
>
> ①`mid = (l + r + 1) >> 1`
>
> ​	加一的原因：当`l == r - 1` 的时候这时候`mid == l`,那么当我们check成功的时候就将`l = mid `相当于区间没有变死循环了；
>
> ```C++
> if(check(mid)) l = mid;
> else r = mid - 1;
> ```
>
> ​	②`mid = (l + r) >> 1`
>
> ```cpp
> if(check(mid)) r = mid;
> else l = mid + 1;
> ```
>
> 模板：
>
> ```cpp
> //区间为[l, r]被划分为[l, mid]和[mid + 1, r]时使用
> //即符合条件的在mid左边，包括mid
> int bsearch(int l, int r)
> {
>     while(l < r)
>     {
>         int mid = l + r >> 1;
>         if(check(mid)) r = mid;//check()判断mid是否满足性质
>         else l = mid + 1;
>     }
>     return l;
> }
> 
> //区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用
> //即符合条件的在mid右边包括mid
> int bsearch(int l, int r)
> {
>     while(l < r)
>     {
>         int mid = (l + r + 1) >> 1;
>         if(check(mid)) l = mid;
>         else r = mid - 1;
>     }
>     return l;
> }
> ```
>
> ### 浮点二分：	
>
> [x 的平方根 - 力扣](https://leetcode.cn/problems/sqrtx/submissions/)
>
> ```C++
>     double mySqrt(int x) 
>     {
>         double l = 0, r = x;
>         while(r - l > 1e-11)
>         {
>             double mid = l + (r - l) / 2;
>             if(mid * mid <= x) l = mid;
>             else r = mid;
>         }
>         return r;
>     }
> ```
>
> 