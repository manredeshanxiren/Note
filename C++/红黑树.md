# 红黑树

## Ⅰ.红黑树的概念

> 红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或 Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路 径会比其他路径长出俩倍，因而是接近平衡的。
>
> ![image-20230904192915437](C:/Users/jason/AppData/Roaming/Typora/typora-user-images/image-20230904192915437.png)

## Ⅱ.红黑树的性质

> ①每个结点不是红色就是黑色
>
> ②根节点是黑色的 
>
> ③如果一个节点是红色的，则它的两个孩子结点是黑色的
>
> ④ 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均 包含相同数目的黑色结点 
>
> ⑤每个叶子结点都是黑色的(此处的叶子结点指的是空结点)
>
> 思考：为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点 个数的两倍？
>
> 因为满足以上的性质我们可以得到
>
> 最短的路径： 全黑
>
> 最长的路径：一黑一红
>
> 所以最大就是最长的路径是最短路径的两倍；

## Ⅲ. 红黑树节点的定义

> ```cpp
> // 节点的颜色
> enum Color{RED, BLACK};
> // 红黑树节点的定义
> template<class ValueType>
> struct RBTreeNode
> {
>  RBTreeNode(const ValueType& data = ValueType()，Color color = RED)
>      : _pLeft(nullptr), _pRight(nullptr), _pParent(nullptr)
>      , _data(data), _color(color)
>  {}
>  RBTreeNode<ValueType>* _pLeft;   // 节点的左孩子
>  RBTreeNode<ValueType>* _pRight;  // 节点的右孩子
>  RBTreeNode<ValueType>* _pParent; // 节点的双亲(红黑树需要旋转，为了实现简单给
> 出该字段)
>  ValueType _data;            // 节点的值域
>  Color _color;               // 节点的颜色
> };
> 
> ```
>
> 思考：在节点的定义中，为什么要将节点的默认颜色给成红色的？
>
> 因为红黑树有一个原则就是每条路径的黑色节点数量相同，那么当我们插入一个节点默认颜色给成黑色的时候就会造成这个原则被打破。

## Ⅳ.红黑树结构

> 为了后续实现关联式容器简单，红黑树的实现中增加一个头结点，因为跟节点必须为黑色，为了 与根节点进行区分，将头结点给成黑色，并且让头结点的 pParent 域指向红黑树的根节点，pLeft 域指向红黑树中最小的节点，_pRight域指向红黑树中最大的节点，如下：
> ![image-20230831205219366](https://s2.loli.net/2023/08/31/MtAqEalTiKdOrPp.png)

## Ⅴ. 红黑树的插入操作

> 红黑树是在二叉搜索树的基础上加上其平衡限制条件，因此红黑树的插入可分为两步：
>
> ①插入新节点
>
> ```cpp
> bool Insert(const pair<k, v>& kv)
> 	{
> 		if (_root == nullptr)
> 		{
> 			_root = new node(kv);
> 			return true;
> 		}
> 
> 		node* parent = nullptr;
> 		node* cur = _root;
> 		while (cur)
> 		{
> 			if (cur->_kv.first < kv.first)
> 			{
> 				parent = cur;
> 				cur = cur->_right;
> 			}
> 			else if (cur->_kv.first > kv.first)
> 			{
> 				parent = cur;
> 				cur = cur->_left;
> 			}
> 			else
> 			{
> 				return false;
> 			}
> 		}
> 
> 		cur = new node(kv);
> 		if (parent->_kv.first > cur->_kv.first)
> 		{
> 			parent->_left = cur;
> 
> 		}
> 		else
> 		{
> 			parent->_right = cur;
> 		}
> 		cur->_parent = parent;
> 
> 		while (parent && parent->_col == RED)
> 		{
> 			node* GrandFather = parent->_parent;
> 			if (GrandFather->_left == parent)
> 			{
> 				node* uncle = GrandFather->_right;
> 				//情况1 ： u存在且为红，变色处理，并且向上调整
> 				if (uncle && uncle->_col == RED)
> 				{
> 					parent->_col = BLACK;
> 					uncle->_col = BLACK;
> 					GrandFather->_col = RED;
> 
> 					//继续往上调整
> 					cur = GrandFather;
> 					parent = cur = parent;
> 				} 
> 				else // 情况2 + 3：u不存在/u存在且为黑，旋转+变色
> 				{
> 					//     g
> 					//   p   u
> 					// c 
> 					if (cur = parent->_left)
> 					{
> 						RotateR(GrandFather);
> 						parent->_col = BLACK;
> 						GrandFather->_col = RED;
> 					}
> 					else
> 					{
> 						RotateL(parent);
> 						RotateR(grandfather);
> 
> 						cur->_col = BLACK;
> 						GrandFather->_col = RED;
> 					}
> 					break;
> 				}
> 			}
> 			else
> 			{
> 				//    g
> 				//u       p
> 				//               c
> 				node* uncle = GrandFather->_left;
> 				//情况1 ： u存在且为红，变色处理，并且向上调整
> 				if (uncle && uncle->_col == RED)
> 				{
> 					parent->_col = BLACK;
> 					uncle->_col = BLACK;
> 					GrandFather->_col = RED;
> 
> 					//继续往上调整
> 					cur = GrandFather;
> 					parent = cur = parent;
> 				}
> 				else//情况2 + 3
> 				{
> 					//    g
> 					//u       p
> 					//               c
> 					if (parent->_right == cur)
> 					{
> 						RotateL(GrandFather);
> 						parent->_col = BLACK;
> 						GrandFather->_col = RED;
> 					}
> 					//     g
> 					//u         p
> 					//     c
> 					else
> 					{
> 						RotateR(parent);
> 						RotateL(GrandFather);
> 						cur->_col = BLACK;
> 						GrandFather->_col = RED;
> 					}
> 					break;
> 				}
> 			}
> 		}
> 		_root->_col = BLACK;
> 		return true;
> 	}
> ```

## Ⅵ. 红黑树的验证

> 红黑树的检测分为两步：
>
> ①检测其是否满足二叉搜索树(中序遍历是否为有序序列)
>
> ②检测其是否满足红黑树的性质
>
> ```cpp
> bool IsBalance()
> 	{
> 		if (_root == nullptr)
> 		{
> 			return true;
> 		}
> 
> 		if (_root&& _root->_col = RED)
> 		{
> 			cout << "根节点是红色的" << endl;
> 		}
> 		
> 		int benchmark = 0;
> 		node* cur = _root;
> 		while (cur)
> 		{
> 			if (cur->_col == BLACK)
> 				benchmark++;
> 			cur = cur->_left;
> 		}
> 
> 		return _check(_root, 0, benchmark);
> 	}
> 
> 
> bool _check(node* root, int BlackNum, int benchmark)
> 	{
> 		if (root == nullptr)
> 		{
> 			if (benchmark != BlackNum)
> 			{
> 				cout << "黑色节点数量不相同" << endl;
> 				return false;
> 			}
> 			return true;
> 		}
> 
> 		if (root->_col == BLACK)
> 		{
> 			BlackNum++;
> 		}
> 
> 		if (root->_col == RED && root->parent && root->parent->_col == RED)
> 		{
> 			cout << "出现了连续的红色" << endl;
> 		}
> 
> 		return _check(root->_left, BlackNum, benchmark) &&
> 			_check(root->_right, BlackNum, benchmark);
> 
> 	}
> ```

## Ⅶ.红黑树的删除

> 红黑树的删除本节不做讲解，有兴趣的同学可参考：《算法导论》或者《STL源码剖析》
>
> http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html





