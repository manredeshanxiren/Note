# C++入门

## Ⅰ.命名空间:

> 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，`namespace`关键字的出现就是针对这种问题的  

例如:

> 在C语言的情景中当我们引用`<stdlib.h>`这个库的时候当我们在去定义一个名为`rand`的变量的时候这时候就会报错了:
>
> ```c++
> #include <stdio.h>
> #include <stdlib.h>
> int rand = 10;
> // C语言没办法解决类似这样的命名冲突问题，所以C++提出了namespace来解决
> int main()
> {
> 	printf("%d\n", rand);
> 	return 0;
> }
> // 编译后后报错：error C2365: “rand”: 重定义；以前的定义是“函数”
> ```
>
> 

### Ⅰ. Ⅰ 命名空间的定义:

> 定义命名空间，需要使用到`namespace`关键字，后面跟命名空间的名字，然后接一对`{}`即可，`{}`中即为命名空间的成员。

Ⅰ. Ⅰ .Ⅰ正常的命名空间定义:

```c++
namespace sxr
{
	// 命名空间中可以定义变量/函数/类型
	int rand = 10;
	int Add(int left, int right)
	{
		return left + right;
	}
	struct Node
	{
		struct Node* next;
		int val;
	};
}
```

Ⅰ. Ⅰ .Ⅱ命名空间的嵌套:

> 如下的例子就是命名空间`sxr1`嵌套命名空间`sxr2`的例子;

```c++
namespace sxr1
{
	int a;
	int b;
	int Add(int left, int right)
	{
		return left + right;
	}
	namespace sxr2
	{
		int c;
		int d;
		int Sub(int left, int right)
		{
			return left - right;
		}
	}
}
```

拓展:

> ①同一个工程中**允许存在多个相同名称的命名空间**,编译器最后会合成同一个命名空间中。
>
> ②一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中    

### Ⅰ. Ⅱ命名空间的使用:

①加命名空间名称及作用域限定符`::`:

```c++
int main()
{
	printf("%d\n", N::a);
	return 0;
}
```

②使用`using`将命名空间中某个成员引入(部分):

> 如下的案例是只将命名空间`N`中的`b`变量进行了引入:
>
> ```c++
> using N::b;
> int main()
> {
> 	printf("%d\n", N::a);
> 	printf("%d\n", b);
> 	return 0;
> }
> ```
>
> 

③使用`using namespace` 命名空间名称引入(全局):

> 这种方式会将整个命名空间中的名称全部引入，不是很推荐这种方法;
>
> ```c++
> using namespce N;
> int main()
> {
> 	printf("%d\n", N::a);
> 	printf("%d\n", b);
> 	Add(10, 20);
> 	return 0;
> }
> ```

## Ⅱ. C++的输入和输出:

> 在C语言中我们通常使用`scanf`和`printf`两个函数来实现输入和输出，并且他们是包含在标准输入输出库`<stdio.h>`中;
>
> 在C++中,是采用的`cin`标准输入对象(键盘)和`cout`标准输出对象(控制台)两个,在使用的过程中需要引头文件`<iostream>`和命名空间`std`;
>
> 例如:用C++的方式我们来输出`Hello world`;
>
> ```c++
> #include<iostream>
> // std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中
> using namespace std;
> int main()
> {
> 	cout << "Hello world!!!" << endl;
> 	return 0;
> }
> ```
>
> 

拓展:

> - 使用`cout`标准输出对象(控制台)和`cin`标准输入对象(键盘)时，必须包含`<iostream>`头文件以及按命名空间使用方法使用`std`;
> - `cout`和`cin`是全局的流对象，`endl`是特殊的C++符号，表示换行输出，他们都包含在包含`<iostream>`头文件中;
> - `<<`是流插入运算符，`>>`是流提取运算符 ;
> - <font color = "red">使用C++输入输出更方便，不需要像`printf/scanf`输入输出时那样，需要手动控制格式。C++的输入输出可以自动识别变量类型  </font>

注意:

> 早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持<iostream.h>格式，后续编译器已不支持，因
> 此推荐使用<iostream>+std的方式。  

## Ⅲ. 缺省参数:

### Ⅲ. Ⅰ 缺省参数的概念:

> 缺省参数是**声明或定义函数时**为函数的参数指定一个缺省值。在调用该函数时，如果没有指定实参则采用该形参的缺省值，否则使用指定的实参  

例如:

> ```c++
> void Func(int a = 0)
> {
> 	cout<<a<<endl;
> }
> int main()
> {
> 	Func(); // 没有传参时，使用参数的默认值
> 	Func(10); // 传参时，使用指定的实参
> 	return 0;
> }
> ```

### Ⅲ. Ⅱ 缺省参数的分类:

> ①全缺省参数 :
>
> ```c++
> void Func(int a = 10, int b = 20, int c = 30)
> {
> 	cout<<"a = "<<a<<endl;
> 	cout<<"b = "<<b<<endl;
> 	cout<<"c = "<<c<<endl;
> }
> ```
>
> ②半缺省参数:
>
> **注意**:
>
> (1)半缺省参数必须**从右往左**依次来给出，不能间隔着给;
> (2) 缺省参数不能在函数声明和定义中同时出现;
>
> <font color = 'red'>所以当函数的声明和定义分离时，我们需要在声明中去给缺省参数，而不能在定义中;</font>
>
> (3) 缺省值必须是常量或者全局变量;
> (4) C语言不支持（编译器不支持 );
>
> ```c++
> //a.h
> void Func(int a = 10);
> // a.cpp
> void Func(int a = 20)
> {}
> // 注意：如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值
> ```

## Ⅳ 函数重载:

### Ⅳ. Ⅰ 函数重载概念:

> 函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的**同名函数**，<font color = 'blue'>**这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同**</font>，常用来处理实现功能类似数据类型不同的问题 ;

## Ⅳ. Ⅱ分类:

> ①参数类型不同:
>
> ```c++
> int Add(int left, int right)
> {
> 	cout << "int Add(int left, int right)" << endl;
> 	return left + right;
> }
> double Add(double left, double right)
> {
> 	cout << "double Add(double left, double right)" << endl;
> 	return left + right;
> }
> ```
>
> ②参数个数不同:
>
> ```c++
> void f()
> {
> 	cout << "f()" << endl;
> }
> void f(int a)
> {
> 	cout << "f(int a)" << endl;
> }
> ```
>
> ③参数的类型顺序不同:
>
> ```c++
> void f(int a, char b)
> {
> 	cout << "f(int a,char b)" << endl;
> }
> void f(char b, int a)
> {
> 	cout << "f(char b, int a)" << endl;
> }
> ```

## Ⅳ. Ⅲ C++支持函数重载的原理--名字修饰(name Mangling)  

> 对于函数重载,C语言是支持的,那么C++在运行的过程中会不会导致运行速度变慢呢？
>
> 这就要解释一下函数重载的原理了！

在C/C++中，一个程序要运行起来，需要经历以下几个阶段：**预处理、编译、汇编、链接;**

①实际项目通常是由多个头文件和多个源文件构成，而通过C语言阶段学习的编译链接，我们可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标文件中没有Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？

②所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符号表中找Add的地址，然后链接到一起。	    

③那么链接时，面对Add函数，链接接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。  

④由于Windows下vs的修饰规则过于复杂，而Linux下g++的修饰规则简单易懂，下面我们使用了`g++`演示了这个修饰后的名字  

⑤通过下面我们可以看出`gcc`的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度+函数名+类型首字母】

- 采用C语言编译器编译后结果 :

> 在linux下，采用gcc编译完成后，函数名字的修饰没有发生改变。  

```c++
00000000004004cd <func>:
  4004cd:	55                   	push   %rbp
  4004ce:	48 89 e5             	mov    %rsp,%rbp
  4004d1:	5d                   	pop    %rbp
  4004d2:	c3                   	retq   

00000000004004d3 <main>:
  4004d3:	55                   	push   %rbp
  4004d4:	48 89 e5             	mov    %rsp,%rbp
  4004d7:	b8 00 00 00 00       	mov    $0x0,%eax
  4004dc:	5d                   	pop    %rbp
  4004dd:	c3                   	retq   
  4004de:	66 90                	xchg   %ax,%ax

```

- 采用C++编译器编译后结果:

> 在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参数类型信息添加到修改后的名字中  

```c++
00000000004004fd <_Z4funcv>:
  4004fd:	55                   	push   %rbp
  4004fe:	48 89 e5             	mov    %rsp,%rbp
  400501:	5d                   	pop    %rbp
  400502:	c3                   	retq   

0000000000400503 <main>:
  400503:	55                   	push   %rbp
  400504:	48 89 e5             	mov    %rsp,%rbp
  400507:	b8 00 00 00 00       	mov    $0x0,%eax
  40050c:	5d                   	pop    %rbp
  40050d:	c3                   	retq   
  40050e:	66 90                	xchg   %ax,%ax

```

⑥通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。  

⑦如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办法区分。  

## Ⅴ 引用:

### Ⅴ. Ⅰ 应用的概念:

> 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。  

语法:`类型& 引用变量名(对象名) = 引用实体；`

```c++
void TestRef()
{
	int a = 10;
	int& ra = a; //<====定义引用类型
	printf("%p\n", &a);
	printf("%p\n", &ra);
}
```

<font color = 'red'>注意:**引用类型**必须和引用实体是**同种类型**的</font>  

### Ⅴ. Ⅱ引用特性:

> -  引用在定义时必须初始化
> -  一个变量可以有多个引用
> -  引用一旦引用一个实体，再不能引用其他实体  	

### Ⅴ. Ⅲ常引用:

> ```c++
> void TestConstRef()
> {
> 	const int a = 10;
> 	//int& ra = a; // 该语句编译时会出错，a为常量
> 	const int& ra = a;
> 	// int& b = 10; // 该语句编译时会出错，b为常量
> 	const int& b = 10;
> 	double d = 12.34;
> 	//int& rd = d; // 该语句编译时会出错，类型不同
> 	const int& rd = d;
> }
> ```

### Ⅴ. Ⅳ 使用场景:

> ①做参数:
>
> ```c++
> void Swap(int& left, int& right)
> {
> 	int temp = left;
> 	left = right;
> 	right = temp;
> }
> ```
>
> ②做返回值 
>
> - 如果函数返回时，出了函数作用域，如果返回对象还在(还没还给系统)，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回  
> - 因为在函数返回值的过程中会建立一个临时变量（很小时为寄存器变量，较大的时候提前建立在函数栈帧）用于传输返回值，那么当我们的待返回变量出了作用域还未被销毁，我们则可以借助引用来充分利用空间；
>
> ```c++
> int& Count()
> {
> 	static int n = 0;
> 	n++;
> 	// ...
> 	return n;
> }
> ```
>
> - 错误示范：
>
>   因为c的作用域仅在add函数内部那么当我们第一次执行完add后虽然函数栈帧销毁了但是存储c的栈帧里还保存着3;当我们再次调用add函数的时候c处就改为了7，所以第一次输出ret的结果就是7.那么为什么第二次输出就成了随机值的原因是因为cout也是一个函数那么cout被调用了两次将原本存储c的栈帧给覆盖了。
>
>   ```c++
>   int& add(int a, int b)
>   {
>   	int c = a + b;
>   	return c;
>   }
>   int main()
>   {
>   	int& ret = add(1, 2);
>   	add(3,4);
>   	cout << "add(1,2) is:" << ret << endl;
>   	cout << "add(1,2) is:" << ret <<endl;
>       return 0;
>   }
>   ```
>
>   运行结果：
>
>   ![image-20230306213803933](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230306213803933.png)

### Ⅴ. Ⅶ 引用和指针:

①复制/初始化，权限只能缩小不能放大：

> ```c++
>     //权限放大
> 	const int c = 2;
> 	int& d = c;
> 
> 	const int* p1 = NULL;
> 	int* p2 = p1;
> 
> 	//权限保持
> 	const int c = 2;
> 	const int& d = c;
> 
> 	const int* p1 = NULL;
> 	const int* p2 = p1;
> 	
> 	//权限缩小
> 	int x = 1;
> 	const int& y = x;
> 
> 	int* p3 = NULL;
> 	const int* p4 = p3;
> ```
>
> 



- 我们可以看到从定义上来说引用是没有创建新的空间，而从底层的反汇编语言来看它和指针的原理是相近的。

![image-20230307191323093](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230307191323093.png)

- 引用和指针的不同点：

  > 1.引用概念上定义一个变量的别名，指针存储一个变量地址
  >
  > 2.引用在定义时<u>**必须初始化**</u>，指针没有要求
  >
  > 3.引用在初始化时引用一个实体后，就<u>**不能再引用其他实体**</u>，而指针可以在任何时候指向任何
  > 一个同类型实体
  >
  > 4. <u>**没有NULL引用**</u>，但有NULL指针  
  > 5. 在sizeof中含义不同：<u>**引用结果为引用类型的大小**</u>，但指针始终是地址空间所占字节个数(32
  >    位平台下占4个字节)  
  > 6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小  
  > 7. 有多级指针，但是<u>**没有多级引用**</u>  
  > 8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理  
  > 9. 引用比指针使用起来相对更安全  

## Ⅵ内联函数：

> 那么要引入内联函数首先在C语言中存在一种叫<u>**宏常量**</u>的东西.
>
> 因为宏常量具有以下的缺点：
>
> - 不能调试
>
> - 没有类型安全的检查
>
> - 有些场景下非常复杂,容易出错，不容易掌握
>
>   所以C++推荐使用const和enum代替宏常量，inline(内联函数)代替宏函数；

### Ⅵ. Ⅰ 概念：

> 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调
> 用建立栈帧的开销，内联函数提升程序运行的效率。  
>
> 例如：
>
> ```cpp
> inline int add(int a, int b)
> {
> 	int c = a + b;
> 	return c;
> }
> ```
>
> 

### Ⅵ. Ⅱ特性：

> 1. <u>**inline**</u>是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会
>    用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运
>    行效率
>
> 2. 但是并不是我们使用内联函数，编译器就一定会展开。编译器也会选择性的进行优化，当函数的代码实现很长的时候或者递归等情况的时候，就会选择去call函数了。也就是说内联说明只是向编译器发出的一个请求，编译器可以选择忽略这条请求。
>
> 3. 内联函数不建议将定义和声明分离，因为这样容易导致链接错误。解决方法：我们可以直接在.h文件中定义。
>
>    因为正常的函数也就是非内联函数编译器在编译的过程中会将它的字符存储到一个符号表里并且对应它的地址，而内联函数因为它不需要被call所以编译器不会给它产生地址并且将它放到符号表内，所以就会导致链接的时候产生错误。
>

## Ⅶ auto关键字

### Ⅶ. Ⅰ auto简介：

> C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一
> 个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得 。
>
> ```c++
> #include<iostream>
> using namespace std;
> int main()
> {
> 	int a = 10;
> 	auto b = a;
> 	auto c = 'a'; 
> 	cout << typeid(b).name() << endl;
> 	cout << typeid(c).name() << endl;
> 	return 0;
> }
> ```
>
> <u>**注意**</u>：使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto
> 的实际类型。因此auto并非是一种<u>**“类型”**</u>的声明，而是一个类型声明时的<u>**“占位符”**</u>，编译器在编
> 译期会将auto替换为变量实际的类型 。
>
> 对于`typedef`是比较容易出错的：
>
> ```c++
> typedef char* pstring;
> int main()
> {
> 	const pstring p1; // 编译成功还是失败？
>     //失败   char* const pstring p1; 对于一个常量来说是需要初始化的。
> 	const pstring* p2; // 编译成功还是失败？
>     //成功 const char** p2;
> 	return 0;
> }
> ```
>
> 这就要求在声明变量的时候清楚地知道表达式的类型。然而有时候要做到这点并非那么容易。 

### Ⅶ. Ⅱ auto使用细则：

> ①auto与指针和引用结合起来使用：
>
> 用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&
>
> ```c++
> int main()
> {
> 	int x = 10;
> 	auto a = &x;
> 	auto* b = &x;
> 	auto& c = x;
> 	cout << typeid(a).name() << endl;
> 	cout << typeid(b).name() << endl;
> 	cout << typeid(c).name() << endl;
> 	*a = 20;
> 	*b = 30;
> 	c = 40;
> 	return 0;
> }
> ```
>
>   ②在同一行定义多个变量：
>
> 当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量  
>
> ```c++
> void TestAuto()
> {
> 	auto a = 1, b = 2;
> 	auto c = 3, d = 4.0; // 该行代码会编译失败，因为c和d的初始化表达式类型不同
> }
> ```

### Ⅶ. Ⅲ auto不能推导的场景：

> 1. auto不能作为函数的参数  
>
>    ```cpp
>    // 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导
>    void TestAuto(auto a)
>    {}
>    ```
>
> 2. auto不能直接用来声明数组  
>
>    ```cpp
>    void TestAuto()
>    {
>    	int a[] = {1,2,3};
>    	auto b[] = {4，5，6};
>    }
>    ```
>
> 3. 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法  
>
> 4. auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用  

## Ⅷ 基于范围的for循环

### Ⅷ. Ⅰ 语法

> 对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因
> 此C++11中引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范
> 围内用于迭代的变量，第二部分则表示被迭代的范围 。
>
> ```cpp
> void TestFor()
> {
> 	int array[] = { 1, 2, 3, 4, 5 };
> 	for(auto& e : array)
> 	e *= 2;
> 	for(auto e : array)
> 	cout << e << " ";
> 	return 0;
> }
> ```
>
> **注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环**  

### Ⅷ. Ⅱ 范围for的使用条件  

> ①for循环迭代的范围必须是确定的 ：
>
> 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供
> begin和end的方法，begin和end就是for循环迭代的范围 。
>
> **注意：以下代码就有问题，因为for的范围不确定**
>
> ```cpp
> void TestFor(int array[])
> {
> 	for(auto& e : array)
> 	cout<< e <<endl;
> }
> ```
>
> ②迭代的对象要实现++和==的操作。(关于迭代器这个问题，以后会讲，现在提一下，没办法
> 讲清楚，现在大家了解一下就可以了)  

## Ⅸ 指针空值nullptr(C++11)  

> ①C++98中的指针空值 ：
>
> 在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现
> 不可预料的错误，比如未初始化的指针。如果一个指针没有合法的指向，我们基本都是按照如下
> 方式对其进行初始化  
>
> NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码 ：
>
> ```cpp
> #ifndef NULL
> #ifdef __cplusplus
> #define NULL 0
> #else
> #define NULL ((void *)0)
> #endif
> #endif
> ```
>
> 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何
> 种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如 ：
>
> ```cpp
> void f(int)
> {
> 	cout<<"f(int)"<<endl;
> }
> void f(int*)
> {
> 	cout<<"f(int*)"<<endl;
> }
> int main()
> {
> 	f(0);
> 	f(NULL);
> 	f((int*)NULL);
> 	return 0;
> }
> ```
>
> 程序本意是想通过f(NULL)调用指针版本的f(in*)函数，但是由于NULL被定义成0，因此与程序的初衷相悖。
> 在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void*)0。  、
>
> **注意：**
>
> 1. **在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入**
>    **的**    
> 2. **在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同**  
> 3. **为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr**  