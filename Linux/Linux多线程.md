# 多线程

## 1.线程的概念

> 线程是CPU调度的基本单位，进程是系统资源分配的基本实体

- **Linux中线程的概念**

  Linux内核的设计者，复用PCB的结构体，用PCB模拟线程的TCB，很好的复用了进程的设计方案！

  所以说Linux内部没有真正意义上的线程，而是用进程方案模拟的线程。所以我们的每一个线程的PCB都会指向所属进程的地址空间的内核。因为执行流看到的资源是通过进程地址空间看到的，多个LWP看到的是同一个地址空间，所有的进程可能会共享进程的大部分资源！！

  对此有很多优势：复用代码和结构，实现简单，执行效率高。

运行一个简单的程序观察一下：

注意这个程序编写的时候`makefile`文件编译命令那行要加上`-lpthread`参数.

```cpp
#include<iostream>
#include<unistd.h>
#include<pthread.h>

using namespace std;

void* T1(void* args)
{
    while(1)
    {
        cout << "我是线程1,我正在运行" << getpid() << endl;
        sleep(1);
    }
}

void* T2(void* args)
{
    while(1)
    {
        cout << "我是线程2，我正在运行" << getpid() << endl;
        sleep(1);
    }
}

void* T3(void* args)
{
    while(1)
    {
        cout << "我是线程3，我正在运行" << getpid() << endl;
        sleep(1);
    }
}

int main()
{
    pthread_t t1, t2, t3;
    pthread_create(&t1, nullptr, T1, nullptr);
    pthread_create(&t2, nullptr, T3, nullptr);
    pthread_create(&t3, nullptr, T3, nullptr);

    while(1)
    {
        sleep(1);
    }
    return 0;
}

```

我们发现`ps -aL`命令将显示系统上所有用户的所有进程和线程的信息,我们可以看到线程的pid都是相同的，但是对应的LWP也就是对应的在`pthread`库中的线程ID,但是我们发现有个进程的LWP和对应的PID相同，那么我们可以看出这就是对应的进程，操作系统也是通过进程的`pid`来确认对应的进程的。

![image-20240224131840783](https://gitee.com/slow-heating-shaanxi-people/pictrue/raw/master/pmm/image-20240224131840783.png)

## 2.一些前置知识

①物理内存和磁盘之间

- 内存管理的本质：将磁盘中的特定的4KB的块(数据内容)，放入到哪一个物理内存的4KB空间(数据保存的空间)。

- 如果过多的IO，注定了过多的寻址，过多的机械运动，导致效率低下。所以OS在和磁盘这样的设备进行IO交互的时候，绝对不是按照字节单位，而是按照块单位

  a.其中块的大小为4KB

  b.文件系统+编译器的模式：文件(可执行程序+动态库)在磁盘的时候，就是以块的形式存储。

  c.操作系统+内存：内存在实际进行管理的时候，也是要以4KB为单位的

  d.局部性原理的特性：允许我们提前加载正在访问的数据的相邻或者附近的数据。

  e.数据预加载：我们会通过预先加载要访问的数据的附近的数据来减少IO的次数！多加载进来的数据本质：就叫做数据的预加载。

  f.为什么是4KB：IO的基本单位（内核内存+文件系统）都需要提供支持。通过局部性原理，预测未来的命中情况，提高效率。

②地址空间与物理内存之间：

- 虚拟地址(32位为例)：其中是按照10+10+12的方式来划分的；

  其中第一个10位代表一级页表的地址，我们可以通过它在一级页表中寻找找到对应的二级页表，二级页表中对应存储物理地址对应的页框，最后的12位作为对应的偏移量来寻找对应的块。

  这也证明了我们当时C语言学习的不管是什么类型它的地址都只有一个，但是我们对应的类型不可能都只占用一个字节，所以我们访问对应的空间都是基地址+偏移量的方式。

- malloc：我们实际在申请malloc内存的时候，OS只要给用户在虚拟内存上申请即可，当用户程序真正要访问的时候，OS才会申请或者填充页表+申请对应的物理内存。

- 字符型常量如何做到只允许被读取而不允许被修改？假设存在一个`const char* s = "hello wworld"`,s内部保存的是指向字符的虚拟起始地址---*s寻址的时候一定会存在虚拟地址向物理地址的转化----MMU + 查页表的方式 ----对当前的操作进行权限审查 ---- 虽然可以允许被找到，但是如果我们要进行写操作的话，这个操作是非法的 --- MMU会发生异常----OS识别异常 ---- 将异常转化为信号，发送给目标程序 ---- 在从内核转换成用户态的时候，进行信号处理 ----终止程序。

## 3.多线程的优缺点

### 3.1优点

> - 创建一个新线程的代价要比创建一个新进程小得多  
> - 与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多  
> - 线程占用的资源要比进程少很多  
> - 能充分利用多处理器的可并行数量  
> - 在等待慢速I/O操作结束的同时，程序可执行其他的计算任务  
> - 计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现  
> - I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作  

线程有这么多优点一定越多越好吗?不是，一定要合适（进程/线程CPU的个数/核数一致）

### 3.2缺点

> - 性能损失  
>
>   一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型
>   线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的
>   同步和调度开销，而可用的资源不变。  
>
> - 健壮性降低  
>
>   编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了
>   不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。  
>
> - 缺乏访问控制  
>
>   进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响  
>
> - 编程难度提高  
>
>   编写与调试一个多线程程序比单线程程序困难得多  

多线程程序中，任何一个线程崩溃了，都会导致进程的崩溃！

为什么会这样？

系统角度：线程是进程的执行分支，线程崩溃了，就是进程崩溃了。

信号的角度：页表转换的时候, MMU识别写入权限的，没有验证通过，MMU异常->OS识别->给进程发信号。

```cpp
#include<iostream>
#include<unistd.h>
#include<pthread.h>

using namespace std;

int a[2];

void* T1(void* args)
{
    while(1)
    {
        cout << "我是线程1,我正在运行" << getpid() << endl;
        sleep(1);
    }
}

void* T2(void* args)
{
    while(1)
    {
        cout << "我是线程2，我正在运行" << getpid() << endl;
        sleep(1);
    }
}

void* T3(void* args)
{
    int cnt = 0;
    char *s = "hello bit";
    while(1)
    {
        cout << "我是线程3，我正在运行" << getpid() << endl;
        sleep(1);

        if(cnt == 5)  *s = 's';

        cnt++;
    }
}

int main()
{
    pthread_t t1, t2, t3;
    pthread_create(&t1, nullptr, T1, nullptr);
    pthread_create(&t2, nullptr, T3, nullptr);
    pthread_create(&t3, nullptr, T3, nullptr);

    while(1)
    {
        sleep(1);
    }
    return 0;
}
```

![image-20240224163613503](https://gitee.com/slow-heating-shaanxi-people/pictrue/raw/master/pmm/image-20240224163613503.png)

## 4.线程的控制