# Linux进程概念



## 冯诺依曼体系结构:

![image-20230128184442248](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230128184442248.png)

> ①输入，输出设备称之为外围设备，外设(外部设备)一般都会慢一些，以磁盘为例，相对于内存，磁盘是比较慢的;
>
> ②CPU速度是最快的，结论1:在数据层面，一般CPU不和外设直接沟通，而是直接和内存打交道
>
> ③因为有了内存的存在，我们可以对数据做预处理，CPU以后在进行数据计算的时候，根本就不需要访问外设了，只需要和内存进行数据交换即可。
>
> ④那么可执行程序是不是一个文件呢？
>
> 答案是:是，它保存在磁盘中，也就是外设中。
>
> ⑤为什么我们所写的程序必须先被加载到内存中:这是由体系结构所决定的！

需要强调的几点:

> - 这里的存储器指的是内存
> - 不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)
> - 外设(输入或输出设备)要输入或者输出数据，**也只能写入内存或者从内存中读取。**
> - 一句话，所有设备都只能直接和内存打交道。  

## 操作系统:

> 一款对软硬件资源管理的软件;

任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。笼统的理解，操作系统包括:

> - 内核（进程管理，内存管理，文件管理，驱动管理）
>
> - 其他程序（例如函数库， shell程序等等）  

设计OS的目的:

> - 与硬件交互，管理所有的软硬件资源
>
> - 为用户程序（应用程序）提供一个良好的执行环境  

定位:

> - 在整个计算机软硬件架构中，操作系统的定位是： 一款纯正的“搞管理”的软件  

如何理解“管理”:

> - 管理的例子:
>
>   管理者和被管理者，其实是不需要直接沟通的！
>
>   管理者和被管理者没有直接沟通，他如何管理我呢？
>
>   管理的本质：对被管理对象的数据做管理;
>
>   - 描述被管理对象:
>
>   通过结构体类型来描述;
>
> - 组织被管理对象 :
>
>   通过链表或其他高效的数据形式来组织对象;

操作系统给我们提供了非常良好的服务，并不代表OS会相信我们，反而，操作系统不相信任何人。

### 计算机软硬件体系结构:  

![image-20230128225649490](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230128225649490.png)

## 进程:

### 进程的概念:

> 内核关于进程的相关数据结构 + 当前进程的代码和数据;

### 描述进程-PCB:

> - 进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合。
> - 课本上称之为PCB（process control block）， Linux操作系统下的PCB是: task_struct  

### 为什么进程管理中需要PCB:

> 1.bash命令行解释器，本质上它也是一个进程;
>
> 2.命令行启动的所有程序，最终都会变成进程，而该进程对应的父进程都是bash(如何做到的);

### 查看进程:

> 进程的信息可以通过 /proc 系统文件夹查看  
>
> ![image-20230129211620514](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230129211620514.png)

> 大多数进程信息同样可以使用top和ps这些用户级工具来获取  
>
> 'ps aux | grep test | grep -v grep'
>
> ![image-20230129211815037](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230129211815037.png)

### 如何创建子进程:

例如:

```
#include<stdio.h>                                                                            #include<unistd.h>                                                                            #include<sys/types.h>                                                                       int main()                                                                                   {                                                                                           	pid_t ret = fork();                                                                         if(ret == 0)                                                                                 {                                                                                            //子进程                                                                                      printf("我是子进程，我的pid是：%d，我的父进程是：%d",getpid(),getppid());                          sleep(1);                                                                                   }                                                                                           else if(ret > 0)                                                                             {                                                                                            //父进程                                                                                     while(1)                                                                                     {                                                                                              printf("我是父进程，我的pid是：%d，我的父进程是：%d"，getpid(),getppid());                        sleep(2);                                                                                 }                                                                                          }                                                                                            return 0;                                                                                  } 




```

运行结果:

![image-20230129211229756](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20230129211229756.png)

> a.fork之后，执行流会变成2个执行流;
>
> b.fork之后，谁先运行由调度器运行;
>
> c.fork之后，fork之后的代码共享，通常我们通过if 和 ifelse来进行执行流分流;

原理:

> - fork做了什么?:
>
> 创建了子进程，只会创建一个子进程对应的pcb，这个pcb内部的大部分内容都是和父进程相同的，并且他们共同指向同一段代码和数据;
>
> - fork如何看待？
>
>   进程在运行的时候，是具有独立性的;
>
>   父子进程也具有独立性;
>
>   代码：是只读的；
>
>   数据：当有一个执行流尝试修改数据的时候，OS会自动给我们当前的进程触发写时拷贝（操作系统会拷贝一份数据让进程去另一个地方修改，而不会修改原始数据）
>
> - 如何理解fork();两个返回值？
>
>   对于一个函数来说，函数执行return的时候，函数的主体功能就已经实现了。
>
>   fork函数本质上来说时OS为我们所提供的函数！
>
>   因为当执行完fork函数的主体的时候，主进程被调度和子进程也会被执行所以在fork的函数内部return这段语句被执行了两次，所以返回了两个返回值。
